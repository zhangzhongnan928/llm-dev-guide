const workflowData = [
  {
    title: "需求和架构规划",
    description: "在这一步骤中，你将明确项目需求并设计初步架构。这是项目成功的关键基础。",
    inputs: [
      {
        label: "你的项目简述（1-2句话）",
        placeholder: "例如：我想开发一个简单的待办事项应用，它可以让用户创建、编辑和删除任务。"
      },
      {
        label: "主要功能列表",
        placeholder: "例如：\n1. 用户注册和登录\n2. 添加/编辑/删除任务\n3. 任务分类和标签"
      }
    ],
    promptTemplate: `设计一个软件架构，用于[项目描述]。包括：
- 主要组件及其关系（每个模块使用唯一ID）
- 数据模型和流程（包含接口契约）
- 推荐的技术栈及理由
- 实施路线图和明确的里程碑
- 潜在技术挑战和缓解策略
- 模块大小约束（建议≤200行）
- 模块依赖关系图（推荐使用Mermaid格式）
- 安全考虑和威胁模型
- 性能需求和约束
- 并发考虑和线程安全要求
- 数据隐私和合规要求（GDPR等）
- 版本策略和向后兼容计划

主要功能列表：
[主要功能列表]

使用图表、要点和简洁的解释进行格式化。`,
    nextActions: [
      "1. 复制上面的提示词到Cursor中",
      "2. 将[项目描述]替换为你的项目简介和功能列表",
      "3. 让LLM生成架构设计文档",
      "4. 保存生成的架构设计到GitHub仓库中"
    ],
    faqs: [
      "如果LLM输出太笼统或通用，尝试提供更具体的项目细节",
      "确保提示词中包含所有重要的架构考虑因素",
      "对于小型项目，可以简化一些架构元素，但保留模块化设计思想",
      "如果对技术栈不确定，可让LLM提供几个备选方案并解释各自优劣"
    ]
  },
  {
    title: "知识管理策略",
    description: "为项目建立知识管理策略，确保各开发阶段之间的连续性。",
    inputs: [
      {
        label: "项目名称",
        placeholder: "例如：TaskMaster待办应用"
      }
    ],
    promptTemplate: `为[项目名称]创建上下文管理策略：
1. 定义项目上下文文档结构，以维持会话之间的连续性
2. 创建带有唯一ID和标准化摘要的模块参考系统（每个模块≤100字）
3. 建立接口契约和模式定义（使用OpenAPI/Swagger、GraphQL或类似IDL）
4. 设计显示组件之间关键关系的知识图谱
5. 创建设计决策日志，跟踪架构选择和基本原理
6. 定义处理开发会话之间上下文交接的机制
7. 建立标准化的日志记录和可观察性策略
8. 创建项目术语表，用于特定领域术语

优先考虑信息密度和可检索性。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[项目名称]为你的项目名称",
      "3. 让LLM生成知识管理策略",
      "4. 将生成的策略保存到GitHub仓库中，作为项目文档的一部分"
    ],
    faqs: [
      "良好的知识管理可显著减少在LLM上下文窗口中重复信息的需要",
      "创建简洁但信息丰富的模块摘要可大大提高后续开发效率",
      "如果项目较小，可以简化知识管理策略，但保持一致的命名和文档结构",
      "定期更新知识文档，确保其始终反映最新的开发状态"
    ]
  },
  {
    title: "提示词工程策略",
    description: "设计有效的提示词策略，以获得更一致、高质量的LLM输出。",
    inputs: [
      {
        label: "项目名称",
        placeholder: "例如：TaskMaster待办应用"
      }
    ],
    promptTemplate: `为[项目名称]创建提示工程策略：
1. 设计提示模板结构，包含清晰的部分：
   - 上下文和背景信息
   - 具体需求和约束
   - 预期输出格式
   - 示例（在有帮助的情况下）
2. 建立提示版本控制和跟踪系统
3. 定义评估提示有效性的指标
4. 创建提示持续改进的反馈循环
5. 开发按开发任务类型组织的提示库
6. 识别常见失败模式和缓解策略
7. 为复杂逻辑和边缘情况设计专门提示

专注于创建产生一致、高质量输出的提示。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[项目名称]为你的项目名称",
      "3. 让LLM生成提示词工程策略",
      "4. 将生成的策略保存到项目文档中",
      "5. 根据生成的策略开始创建项目特定的提示词库"
    ],
    faqs: [
      "好的提示词应包含足够的上下文，但避免不必要的冗余",
      "为不同类型的开发任务（如API开发、UI实现、测试等）创建专门的提示词模板",
      "记录哪些提示词最有效，不断完善您的提示词库",
      "在提示词中明确说明你想要的输出格式和风格"
    ]
  },
  {
    title: "模块化开发",
    description: "按模块分解开发任务，确保每个模块都功能完整且易于集成。",
    inputs: [
      {
        label: "模块ID/名称",
        placeholder: "例如：auth-service 或 task-manager"
      },
      {
        label: "模块功能描述",
        placeholder: "例如：处理用户认证，包括登录、注册和密码重置功能"
      }
    ],
    promptTemplate: `开发[特定模块ID]，遵循以下约束：
- 每个文件最多300行
- 完全独立功能，具有清晰的接口
- 包含所有边缘情况的全面错误处理
- 为所有公共方法和接口提供文档
- 为关键功能添加单元测试
- 实现前先编写伪代码大纲
- 对所有输入实施验证
- 使用一致的错误处理模式
- 解决安全问题：输入验证、身份验证、数据保护
- 避免硬编码的密钥或敏感信息
- 遵循已建立的日志记录标准
- 包括性能考虑和优化
- 谨慎管理外部依赖

模块功能：
[模块功能描述]

注重质量而非数量。此模块必须先独立运行，然后才能集成。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[特定模块ID]为你的模块ID/名称",
      "3. 根据需要调整约束条件",
      "4. 让LLM生成该模块的代码",
      "5. 将生成的代码保存到GitHub仓库中",
      "6. 如有必要，进行代码审查和修改"
    ],
    faqs: [
      "将大模块分解为更小的功能单元，每个单元都有明确的责任",
      "确保模块有完善的错误处理和边缘情况处理",
      "生成的代码量过大时，请LLM分批生成，或更细化模块定义",
      "注意检查生成代码中的安全隐患，尤其是用户输入处理部分"
    ]
  },
  {
    title: "外部依赖管理",
    description: "评估和管理项目中使用的外部依赖，确保安全性和可维护性。",
    inputs: [
      {
        label: "模块/功能名称",
        placeholder: "例如：用户认证模块"
      },
      {
        label: "已考虑使用的依赖（可选）",
        placeholder: "例如：\n1. passport.js\n2. bcrypt\n3. jsonwebtoken"
      }
    ],
    promptTemplate: `评估[模块/功能]的外部依赖：
1. 评估每个建议的依赖项：
   - 社区采用和支持水平
   - 安全漏洞历史
   - 与我们项目的许可兼容性
   - 维护活动和发布频率
   - 性能特性
   - 对整体包大小的影响
2. 考虑每个依赖项的替代方案
3. 建立版本固定策略
4. 创建依赖更新策略
5. 记录集成点和潜在风险

待评估的依赖列表：
[依赖列表]

优先考虑安全性、可维护性和最小依赖占用空间。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[模块/功能]为相关模块名称",
      "3. 让LLM评估需要使用的依赖项",
      "4. 将评估结果保存到项目文档中",
      "5. 基于评估结果选择合适的依赖"
    ],
    faqs: [
      "使用较少但更可靠的依赖通常比使用众多小型依赖更好",
      "检查依赖项的GitHub活跃度、issue响应速度和社区支持",
      "始终记录为什么选择特定依赖，以及可能的替代方案",
      "定期审核项目依赖，及时发现和处理安全隐患"
    ]
  },
  {
    title: "集成策略",
    description: "制定模块之间的集成计划，确保组件可以无缝协作。",
    inputs: [
      {
        label: "模块A（被集成的模块）",
        placeholder: "例如：认证服务"
      },
      {
        label: "模块B（集成目标模块）",
        placeholder: "例如：任务管理器"
      }
    ],
    promptTemplate: `创建连接[模块A]与[模块B]的集成计划：
- 定义确切的接口需求和契约
- 列出潜在的集成点和依赖关系
- 指定所需的数据转换
- 概述集成的测试策略
- 识别潜在的故障点
- 提供回滚机制
- 创建集成验证清单
- 定义所有系统模块的集成顺序
- 解决线程安全和并发问题
- 计划与现有接口的向后兼容性

优先考虑弹性和错误恢复。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[模块A]和[模块B]为相关模块名称",
      "3. 让LLM生成集成计划",
      "4. 保存集成计划到项目文档",
      "5. 根据计划实施模块集成"
    ],
    faqs: [
      "确保集成计划包含详细的错误处理和恢复策略",
      "在实际集成前测试每个模块的独立功能",
      "记录集成过程中的任何变更或调整",
      "考虑创建集成测试，验证模块间交互是否按预期工作"
    ]
  },
  {
    title: "测试框架",
    description: "设计全面的测试策略，确保软件的质量和可靠性。",
    inputs: [
      {
        label: "组件/模块名称",
        placeholder: "例如：用户管理模块"
      }
    ],
    promptTemplate: `为[组件]设计测试策略：
- 核心功能的单元测试（覆盖所有分支）
- 组件交互的集成测试
- 关键流程的用户旅程测试
- 性能基准（包含指标）
- 测试数据生成方法（包括边缘情况）
- UI/UX测试检查点，供人工验证
- 为UI组件创建视觉测试指南
- 为每个测试定义验收标准
- 包括测试质量验证的变异测试
- UI组件的视觉回归测试
- 多线程组件的并发和负载测试
- 安全和渗透测试方法

包括具体的测试用例，包含预期输入/输出和验证方法。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[组件]为相关组件名称",
      "3. 让LLM生成测试策略",
      "4. 保存测试策略到项目文档",
      "5. 根据策略开始实施测试"
    ],
    faqs: [
      "全面的测试策略应包括单元、集成和端到端测试",
      "确保测试覆盖正常场景和异常场景",
      "对复杂逻辑创建详细的测试用例",
      "考虑自动化测试，减少手动测试的工作量"
    ]
  },
  {
    title: "人工验证检查点",
    description: "设置人工验证环节，确保软件功能和用户体验符合预期。",
    inputs: [
      {
        label: "模块/功能名称",
        placeholder: "例如：用户注册流程"
      }
    ],
    promptTemplate: `为[模块/功能]创建人工验证清单：
1. 核心功能验证步骤
   - 列出验证功能按预期工作的具体操作
   - 包括每个操作的预期结果
2. UI/UX验证点
   - 视觉一致性检查
   - 交互流程验证
   - 响应性和性能观察
   - 跨设备和跨浏览器兼容性
3. 手动测试的边缘情况场景
4. 验证潜在错误条件
5. 可用性评估标准
6. 可访问性验证点
7. 用户反馈收集指导

设计此清单，以便人类测试人员在10-15分钟内完成。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[模块/功能]为相关功能名称",
      "3. 让LLM生成人工验证清单",
      "4. 保存验证清单到项目文档",
      "5. 在功能开发完成后，按照清单进行验证"
    ],
    faqs: [
      "人工验证对于评估用户体验和直觉交互至关重要",
      "验证清单应易于执行，并有明确的通过/失败标准",
      "请他人帮助测试，以获得更客观的反馈",
      "记录验证过程中发现的问题，并优先处理"
    ]
  },
  {
    title: "Bug修复协议",
    description: "使用系统化的方法定位并修复软件中的问题。",
    inputs: [
      {
        label: "Bug描述",
        placeholder: "例如：用户点击保存按钮后，表单数据丢失"
      }
    ],
    promptTemplate: `按照此协议修复[描述]中的bug：
1. 通过分析识别根本原因，而非症状
2. 用证据解释你的诊断
3. 提出目标修复，代码变更最小
4. 解释修复的潜在副作用
5. 添加测试以防止回归
6. 列出所有可能受影响的模块
7. 提供验证步骤，确认修复效果
8. 将更改作为独立补丁提交
9. 更新文档以反映修复

不要修改不相关的功能。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[描述]为实际Bug描述",
      "3. 让LLM分析并生成Bug修复方案",
      "4. 实施修复并进行测试",
      "5. 将修复提交到GitHub仓库"
    ],
    faqs: [
      "始终寻找Bug的根本原因，而不只是修复表面症状",
      "确保修复不会引入新的问题",
      "为每个修复的Bug添加测试用例，防止回归",
      "记录Bug的原因和修复方法，作为知识积累"
    ]
  },
  {
    title: "根本原因分析框架",
    description: "深入分析问题的根源，而不仅限于表面症状。",
    inputs: [
      {
        label: "问题描述",
        placeholder: "例如：系统在高负载下出现间歇性数据丢失"
      }
    ],
    promptTemplate: `对[问题描述]执行全面的根本原因分析：
1. 收集所有可观察到的症状和错误消息
2. 确定至少3个可能的潜在原因
3. 为每个假设设计有针对性的诊断测试
4. 评估每个潜在原因的证据
5. 确定最可能的根本原因并提供支持证据
6. 解释从根本原因到观察到的症状的因果链
7. 推荐系统级修复，而不仅仅是缓解症状
8. 建议预防类似问题的措施
9. 分享可能影响其他系统组件的发现

专注于找到问题的真正起源，而不仅仅是解决可见症状。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[问题描述]为实际问题",
      "3. 让LLM进行根本原因分析",
      "4. 根据分析结果制定解决方案",
      "5. 将分析和解决方案保存到项目文档"
    ],
    faqs: [
      "全面收集问题的所有症状和表现形式",
      "考虑多种可能的原因，不要过早锁定单一假设",
      "设计实验来验证或排除各种可能的原因",
      "系统性思考，考虑组件之间的交互如何导致问题"
    ]
  },
  {
    title: "代码审查清单",
    description: "使用结构化方法对代码进行审查，确保代码质量和一致性。",
    inputs: [
      {
        label: "代码或模块描述",
        placeholder: "例如：用户认证模块的实现"
      }
    ],
    promptTemplate: `根据以下标准审查此代码实现：
- 功能完整性
- 安全漏洞
- 性能瓶颈
- 错误处理覆盖范围
- 可维护性问题
- 与需求的一致性
- 接口合约合规性
- 测试覆盖率充分性
- 一致的命名约定
- 文档质量
- 代码复杂性和可读性
- 适当使用注释
- 遵守编码标准
- 资源管理（内存、连接等）

提供包含代码示例的具体改进建议。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 向LLM提供要审查的代码",
      "3. 让LLM进行代码审查",
      "4. 根据审查结果改进代码",
      "5. 将改进后的代码提交到GitHub仓库"
    ],
    faqs: [
      "代码审查应关注功能性和非功能性要求（如安全性、性能）",
      "使用代码审查作为学习机会，了解最佳实践",
      "建立一致的编码风格和惯例",
      "确保错误处理全面且用户友好"
    ]
  },
  {
    title: "UI/UX验证协议",
    description: "确保用户界面和体验符合设计规范和用户预期。",
    inputs: [
      {
        label: "UI组件/页面名称",
        placeholder: "例如：用户注册页面"
      }
    ],
    promptTemplate: `为[UI组件/页面]创建验证协议：
1. 关键用户场景（列出3-5个特定工作流程）
2. 视觉检查点（每个状态应出现的元素）
3. 交互验证点（用户操作和预期响应）
4. 测试边缘情况用户行为
5. 可访问性要求
6. 带注释的屏幕截图的视觉测试指南
7. 性能期望（加载时间、响应性）
8. 跨设备/浏览器兼容性检查
9. 用户测试计划与反馈收集方法
10. 基于用户反馈的迭代改进流程

为每个场景提供人类可验证的测试步骤。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[UI组件/页面]为实际UI组件名称",
      "3. 让LLM生成UI/UX验证协议",
      "4. 按照协议验证UI组件",
      "5. 根据验证结果进行必要的调整"
    ],
    faqs: [
      "UI/UX验证应考虑不同用户类型和使用场景",
      "测试不同设备和屏幕尺寸上的体验",
      "关注交互流程是否直观、响应及时",
      "确保界面元素的一致性和可预测性"
    ]
  },
  {
    title: "项目审查与改进",
    description: "对整个项目进行全面审查，寻找改进的机会。",
    inputs: [
      {
        label: "项目/代码库名称",
        placeholder: "例如：TaskMaster待办应用"
      }
    ],
    promptTemplate: `对[项目/代码库]进行全面审查：
1. 跨模块的命名约定一致性
2. 文件结构和组织评估
3. 重复逻辑或模式的识别
4. 抽象和可重用性的机会
5. 文档完整性和质量
6. API一致性和可用性
7. 错误处理一致性
8. 性能优化机会
9. 安全实践评估
10. 技术债务识别和优先级排序
11. 日志记录和可观察性实现

专注于可维护性和一致性，而不改变核心功能。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[项目/代码库]为项目名称",
      "3. 让LLM进行项目审查",
      "4. 将审查结果整理为改进计划",
      "5. 根据优先级逐步实施改进"
    ],
    faqs: [
      "定期进行项目审查可以减少技术债务积累",
      "关注代码一致性和命名惯例",
      "寻找可复用的模式和可抽象的组件",
      "确保文档与代码同步更新"
    ]
  },
  {
    title: "部署与运维策略",
    description: "制定可靠的部署和运维计划，确保系统稳定运行。",
    inputs: [
      {
        label: "项目名称",
        placeholder: "例如：TaskMaster待办应用"
      }
    ],
    promptTemplate: `为[项目]设计部署和运营策略：
1. 容器化方法（Docker等）
2. 环境配置管理
3. 部署流程阶段和门控
4. 监控和告警设置
5. 性能跟踪指标
6. 日志记录和可观察性实现
7. 回滚程序
8. 灾难恢复计划
9. 扩展策略（水平/垂直）
10. 安全扫描和合规性验证

包括配置示例和操作手册。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 替换[项目]为项目名称",
      "3. 让LLM生成部署和运维策略",
      "4. 将策略保存到项目文档",
      "5. 按照策略准备部署环境和流程"
    ],
    faqs: [
      "考虑不同环境（开发、测试、生产）的配置管理",
      "设计可靠的监控和告警系统，及时发现问题",
      "制定详细的部署流程，包括验证和回滚机制",
      "考虑系统的可扩展性和未来增长需求"
    ]
  },
  {
    title: "持续集成与部署",
    description: "建立自动化的CI/CD流程，提高开发效率和产品质量。",
    inputs: [
      {
        label: "项目描述",
        placeholder: "例如：基于Node.js和React的Web应用"
      }
    ],
    promptTemplate: `为此项目设计CI/CD流水线：
1. 自动化构建流程步骤
2. 测试自动化策略（单元、集成、UI）
3. 部署程序与验证
4. 回滚机制
5. 版本管理方法
6. 监控和告警建议
7. 性能测试集成
8. 安全扫描集成
9. 环境一致性维护
10. 部署后验证步骤

包括流行CI工具的示例配置。`,
    nextActions: [
      "1. 复制提示词到Cursor",
      "2. 提供项目的技术栈和环境信息",
      "3. 让LLM生成CI/CD策略",
      "4. 保存策略到项目文档",
      "5. 根据策略配置CI/CD流程（如GitHub Actions）"
    ],
    faqs: [
      "CI/CD流程应包括自动化测试、构建和部署步骤",
      "确保能够快速发现并修复问题",
      "考虑分支策略与工作流程的匹配",
      "设置适当的质量门槛，确保高质量代码进入生产环境"
    ]
  }
];

export default workflowData;